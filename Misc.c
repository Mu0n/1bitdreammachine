/* PrepTools.c */#include "Misc.h"/*------ InitMacStuff   Inits all the Toolbox managers   This sequence is almost always used as is                      ---------*/void InitMacStuff(void){InitGraf(&qd.thePort);InitFonts();InitWindows();InitMenus();TEInit();InitDialogs(nil);InitCursor();GetDateTime((unsigned long *)(&qd.randSeed));FlushEvents(everyEvent,0);}/*------ End of initMacStuff ------*//*------ Hide Menu bar ---------- This probably breaks with much newer macs */void HideMyMenuBar(void) { Rect rcMBar; short *setMBarHeight;  setMBarHeight=(short *)0x0BAA;  if ( gs_hrgnMBar == 0L) {     gs_dyMBar  =  GetMBarHeight();        *setMBarHeight=0;        rcMBar = qd.screenBits.bounds;    rcMBar.bottom = rcMBar.top + gs_dyMBar;        gs_hrgnMBar = NewRgn();    RectRgn( gs_hrgnMBar, &rcMBar );    UnionRgn( GetGrayRgn(), gs_hrgnMBar, GetGrayRgn() );    PaintOne(nil,gs_hrgnMBar);    } } /*------- End of HideMyMenuBar -------*/ /*--------- Show My Menu Bar -----------*/void ShowMyMenuBar(void) { short *setMBarHeight; setMBarHeight=(short *)0x0BAA;  if( gs_hrgnMBar) {    *setMBarHeight=gs_dyMBar;   DiffRgn(GetGrayRgn(), gs_hrgnMBar, GetGrayRgn());   DisposeRgn(gs_hrgnMBar);   gs_hrgnMBar=0L;   } } /*------- End of Hide Menu Bar -------*/  /*--------- Ranged Random -----------*/unsigned short rangeRandom( unsigned short min, unsigned short max )/* the function will calculate the correct max and min values */{  long range;  long randomNumber;    range = MAX(min,max) - MIN(min,max) + 1;  randomNumber=Random();  randomNumber=ABS(randomNumber);    return( (randomNumber * range)/kRandomUpperLimit+min);}/*--------- End of Ranged Random -----------*//* Mac Plus Area - creates a 512x342 screen centered in the middle, with correctClip region. If the screen is larger than that, makes a border with borderPat as itspattern. */WindowPtr MacPlusArea(Pattern borderPat, Pattern middlePat,Boolean wantMenus, WindowRecord *winrec){WindowPtr window;Rect r;r=qd.screenBits.bounds;r.top=kMenuBarHeight;if(kScreenWidth <=512 && kScreenHeight <=342)  {  WholeScreen(middlePat,wantMenus);  }else  {  if(wantMenus) window=NewWindow(winrec,&r,nil,true,plainDBox,kMoveToFront,false,0); else window=NewWindow(winrec,&(qd.screenBits.bounds),nil,true,plainDBox,kMoveToFront,false,0);  SetPort(window); FillRect(&(window->portRect), borderPat); if(wantMenus) {   PortSize(512,342);   MovePortTo((kScreenWidth-512)/2,(kScreenHeight-342-kMenuBarHeight)/2);  } else { MovePortTo((kScreenWidth-512)/2,(kScreenHeight-342)/2);  PortSize(512,342); } ClipRect(&(window->portRect)); CLS(middlePat,wantMenus); } return window;}WindowPtr ForceMacPlusScreen(Pattern thePat, Boolean wantMenus){WindowPtr window;Rect r;SetRect(&r,0,0,512,342);if(wantMenus) window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);else window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);SetPort(window);FillRect(&(window->portRect), thePat);return window;}/*--------- End of MacPlusArea -----------*//*--------- CLS ---------------*/void CLS(Pattern thePat, Boolean wantMenus){Rect r;WindowPtr window;GetPort(&window);r=window->portRect;r.top=kMenuBarHeight;if(wantMenus) FillRect(&r,thePat);else FillRect(&(window->portRect),thePat);}/*--------- End of CLS --------*//* WholeScreen - Will create a screen-sized featureless window filled with the pattern   of your choice. You are responsible to deal with any previous windows and ports    NOTE: use DisposeWindow to get rid of it when you're done */   WindowPtr WholeScreen(Pattern thePat, Boolean wantMenus){WindowPtr window;Rect r;r=qd.screenBits.bounds;r.top=kMenuBarHeight;if(wantMenus) window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);else window=NewWindow(nil,&(qd.screenBits.bounds),nil,true,plainDBox,kMoveToFront,false,0);SetPort(window);FillRect(&(window->portRect), thePat);return window;}/*--------- End of WholeScreen --------*/short OldLoadFile(SFTypeList myTypes)  {  SFReply reply;      //GetFile reply  short openResult=0; //trails file number  long count;         //used to read the data  Point where={50,50};//SFGetFile dialog location    SFGetFile(where,"\pSelect a file",0L,1,myTypes,0L,&reply);    if(reply.good) FSOpen(reply.fName,reply.vRefNum,&openResult);  return openResult;  }int GetScreenWidth(void)  {  return qd.screenBits.bounds.right-qd.screenBits.bounds.left;  }  int GetScreenHeight(void)  {  return qd.screenBits.bounds.bottom-qd.screenBits.bounds.top;  }void PStringCat(Str255 a, Str255 b)  {  short len;    if((a[0]+b[0]) > 255) len = 255-a[0];  else len = b[0];    BlockMove(&(b[1]),&(a[a[0]+1]),len);  a[0] += len;  }void PStringCopy(Str255 a, Str255 b)  {  BlockMove(a,b,a[0]+1);  }