#ifndef MIDIPORTMAC_C#define MIDIPORTMAC_C#include "stdio.h"#include "serial.h"#define kInputBufferSize 1024extern OSErr gOSErr;extern Boolean gVerbo;// for serial stuffshort gOutputRefNum;short gInputRefNum;Handle gInputBufHandle;Boolean gPortGreenFlag=false;// Parameter blockParamBlockRec myParamBlock;ParmBlkPtr myPBPtr;void MyOpenSerialDriver(void);void MyChangeInputBuffer(void);void MySetHandshakeOptions(short);void TweakClock(Boolean);void MyConfigureThePort(void);void InitSCCA(void);void MyRestoreInputBuffer(void);void MyCloseSerialDriver(void);void PrepParamBlock(void);void MyOpenSerialDriver(void)	{	gOSErr = OpenDriver("\p.AOut",&gOutputRefNum);	if(gOSErr == noErr) 		{		printf("output port successfully opened, refnum=%d \n",gOutputRefNum);		gOSErr = OpenDriver("\p.AIn",&gInputRefNum);		if(gOSErr == noErr) 			{			printf("input port successfully opened, refnum=%d \n",gInputRefNum);			gPortGreenFlag = true;			printf("input refNum %d - output refNum %d\n",gInputRefNum,gOutputRefNum);			return;			}		else printf("can't open in port, code=%d \n",gOSErr);		}	else 		{		printf("can't open out port, code=%d \n",gOSErr);		}	printf("input refNum %d - output refNum %d\n",gInputRefNum,gOutputRefNum);	}void MyChangeInputBuffer(void)	{	gInputBufHandle = NewHandle(kInputBufferSize);	HLock(gInputBufHandle);	SerSetBuf(gInputRefNum, *gInputBufHandle,kInputBufferSize);	}	void MySetHandshakeOptions(short whichBuf)	{	SerShk mySerShkRec;	mySerShkRec.fXOn = 0;	mySerShkRec.fCTS = 0;	mySerShkRec.errs = 0;	mySerShkRec.evts = 0;	mySerShkRec.fInX = 0;	mySerShkRec.fDTR = 0;		gOSErr = Control(whichBuf, 14, &mySerShkRec);		if(gOSErr == noErr) 		{		printf("handshake successful\n");		}	else printf("handshake unsuccesful, code=%d \n",gOSErr);		}void TweakClock(Boolean OutOrIn)	{	Ptr addr;	if(OutOrIn) addr = *(Ptr*)0x1DC;	else addr = *(Ptr*)0x1D8;		addr[2] = 4; //WR0 = register pointer set to WR4	asm{MOVE.B (SP),(SP)} //2.2 us delay		addr[2]=0x84; //WR4 = x32, 1 stop bit, no parity	asm{MOVE.B (SP),(SP)} //2.2 us delay		addr[2] = 11; //WR0 = register pointer set to WR11	asm{MOVE.B (SP),(SP)} //2.2 us delay		addr[2]=0x28; //WR11 = Rx and Tx clock from TRxC pin (HSKi on Macs)	asm{MOVE.B (SP),(SP)} //2.2 us delay		if(gVerbo) printf("external clock control successful\n");	}	//currently unused as of August 2025void MyConfigureThePort(void)	{	const int kConfigParam = 2+data8+noParity+stop10;		gOSErr = SerReset(gOutputRefNum, kConfigParam);		if(gOSErr == noErr) 		{		printf("port configuration successful\n");		}	else printf("port configuration unsuccesful, code=%d \n",gOSErr);		}	void PrepParamBlock(void)	{	long int myMsgLen = 3;	myParamBlock.ioParam.ioRefNum = gOutputRefNum;	myParamBlock.ioParam.ioReqCount = 3;	myParamBlock.ioParam.ioCompletion = nil;	myParamBlock.ioParam.ioVRefNum = 0;	myParamBlock.ioParam.ioPosMode = 0;	myPBPtr = (ParamBlockRec *)&myParamBlock;		}	void MyRestoreInputBuffer(void)	{	SerSetBuf(gInputRefNum, *gInputBufHandle,0);	//HUnlock(gInputBufHandle);	}	void MyCloseSerialDriver(void)	{	gOSErr = KillIO(gOutputRefNum);	if(gOSErr == noErr) gOSErr = CloseDriver(gInputRefNum);	if(gOSErr == noErr) gOSErr = CloseDriver(gOutputRefNum);	}	#endif