/* OffScreen.h *//* InitBitMap: assumes that the BitMap is declared, and that its bound are known andalready set in BitMap->bounds. All the function does is to allocate the proper sizedmemory space in BitMap->rowBytes and BitMap->baseAddr, according to the most efficient size rule for CopyBits usage, which is: the width must be an even multiple of 8 bits which at least equal to the number of bits needed for the width of the image. *//* LoadPicResIntoBitmap: given a resource file name, a picID and a pointer to a declared bitmap,will load said PICT resource into an offscreen bitmap. This function uses InitBitMap,CreateOffscreenGrafPort and DestroyOffscreenBitmap. It sets a temporary offscreen portto draw the PICT resource into the bitmap space, and cleans up everything afterward. *//* LoadPicHandleIntoBitmap: given a pointer to a declared bitmap and a PicHandle (alreadyloaded up), it will draw the Picture into the offscreen BitMap*//* CreateOffscreenGrafPort: can be used for standalone "sprite graphics" which are sizedappropriately for PICT resources, for example. Can also be used for a double buffertechnique, in which a duplicate of the screen can be tailored with "silently", is screensized and then copied over completely in one CopyBits pass into the viewable screen.I'm not sure this is viable for Mac Plus speeds, though. It is much preferable to useCopyBits to stay on the safe side. *//* DestroyOffscreenGrafPort: destroys an offscreen GrafPtr when you're done with it */Boolean InitBitMap(BitMap *loadBM);Boolean LoadPicResIntoBitMap(BitMap *loadBM,int picID);Boolean LoadPicHandleIntoBitMap(BitMap *loadBM, PicHandle myPicH);Boolean CreateOffscreenGrafPort(GrafPtr *newOffscreen, Rect *inBounds);void DestroyOffscreenGrafPort(GrafPtr oldOffscreen);