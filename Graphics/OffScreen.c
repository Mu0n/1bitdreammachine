/* OffScreen.c */#ifndef FALSE#define FALSE 0#define TRUE 1#endif/* InitBitMap: assumes that the BitMap is declared, and that its bound are known andalready set in BitMap->bounds. All the function does is to allocate the proper sizedmemory space in BitMap->rowBytes and BitMap->baseAddr, according to the most efficient size rule for CopyBits usage, which is: the width must be an even multiple of 8 bits which at least equal to the number of bits needed for the width of the image. *//* LoadPicResIntoBitmap: given a resource file name, a picID and a pointer to a declared bitmap,will load said PICT resource into an offscreen bitmap. This function uses InitBitMap,CreateOffscreenGrafPort and DestroyOffscreenBitmap. It sets a temporary offscreen portto draw the PICT resource into the bitmap space, and cleans up everything afterward. *//* LoadPicHandleIntoBitmap: given a pointer to a declared bitmap and a PicHandle (alreadyloaded up), it will draw the Picture into the offscreen BitMap*//* CreateOffscreenGrafPort: can be used for standalone "sprite graphics" which are sizedappropriately for PICT resources, for example. Can also be used for a double buffertechnique, in which a duplicate of the screen can be tailored with "silently", is screensized and then copied over completely in one CopyBits pass into the viewable screen.I'm not sure this is viable for Mac Plus speeds, though. It is much preferable to useCopyBits to stay on the safe side. *//* DestroyOffscreenGrafPort: destroys an offscreen GrafPtr when you're done with it */Boolean InitBitMap(BitMap *loadBM);Boolean LoadPicResIntoBitMap(BitMap *loadBM,int picID);Boolean LoadPicHandleIntoBitMap(BitMap *loadBM, PicHandle myPicH);Boolean CreateOffscreenGrafPort(GrafPtr *newOffscreen, Rect *inBounds);void DestroyOffscreenGrafPort(GrafPtr oldOffscreen);//Assumes you have set the bounds correctly first. this will reserve memory//and give you at least an even number of bytes above the width that you needBoolean InitBitMap(BitMap *loadBM)      {      loadBM->rowBytes = ((loadBM->bounds.right - loadBM->bounds.left + 15) >> 4) << 1;         loadBM->baseAddr =                  NewPtrClear(loadBM->rowBytes * (long) (loadBM->bounds.bottom                                      - loadBM->bounds.top));      return loadBM->baseAddr != nil;      }  Boolean LoadPicResIntoBitMap(BitMap *loadBM,int picID)      {      PicHandle myPicH = NULL;      GrafPtr oldG, newG;      BitMap saveBits;           if(NULL == loadBM) return false;   /* dpo */            GetPort(&oldG);  /* 5 following lines handle the PICT retrieval */                                                                if(NULL== (myPicH=GetPicture(picID)))        {       return false;       }           loadBM->bounds=(*myPicH)->picFrame;      if(!InitBitMap(loadBM))        {        DisposeHandle((Handle)myPicH);        return false;        }/* Next line creates a new port with the correct sized Rect read from the PICT */      if ( ! CreateOffscreenGrafPort(&newG, &(loadBM->bounds)))          {         DisposeHandle((Handle)myPicH);         return false;         }      SetPort(newG);      saveBits = newG->portBits;      SetPortBits(loadBM);      EraseRect(&(loadBM->bounds));        /* Once the offscreen BitMap object is set as the port, draw onto it from the picHandle*/      HLock((Handle)myPicH);      DrawPicture(myPicH,&(loadBM->bounds));      HUnlock((Handle)myPicH);      /* Last lines take care of the cleanup */           SetPortBits(&saveBits);      SetPort(oldG);               DisposeHandle((Handle)myPicH);      DestroyOffscreenGrafPort(newG);             return true;      }Boolean LoadPicHandleIntoBitMap(BitMap *loadBM, PicHandle myPicH)      {      GrafPtr oldG, newG;      BitMap saveBits;           if(NULL == loadBM) return false;   /* dpo */            GetPort(&oldG);             loadBM->bounds=(*myPicH)->picFrame;      if(!InitBitMap(loadBM))        {        return false;        }/* Next line creates a new port with the correct sized Rect read from the PICT */      if ( ! CreateOffscreenGrafPort(&newG, &(loadBM->bounds)))          {         return false;         }      SetPort(newG);      saveBits = newG->portBits;      SetPortBits(loadBM);      EraseRect(&(loadBM->bounds));        /* Once the offscreen BitMap object is set as the port, draw onto it from the picHandle*/      HLock((Handle)myPicH);      DrawPicture(myPicH,&(loadBM->bounds));      HUnlock((Handle)myPicH);/* Last lines take care of the cleanup */           SetPortBits(&saveBits);      SetPort(oldG);               DestroyOffscreenGrafPort(newG);       return true;      }Boolean CreateOffscreenGrafPort(GrafPtr *newOffscreen, Rect *inBounds)      {          GrafPtr savePort;          GrafPtr newPort;                    GetPort(&savePort);    /* need this to restore thePort after OpenPort */          /* since the bits are just memory, let's clear them before we start*/          newPort = (GrafPtr) NewPtrClear(sizeof(GrafPort));    /* allocate the grafPort */          if (MemError() != noErr)              return FALSE;        /* failed to allocate the off-screen port */          /*          the call to OpenPort does the following . . .              allocates space for visRgn (set to screenBits.bounds) and              clipRgn (set wide open)              sets portBits to screenBits              sets portRect to screenBits.bounds              (See Inside Mac: Imaging with QuickDraw,              pages 2-38 to 2-39)              side effect: does a SetPort(&offScreen)          */          OpenPort(newPort);          /* make bitmap the size of the bounds that caller supplied */          newPort->portRect = *inBounds;          newPort->portBits.bounds = *inBounds;          RectRgn(newPort->clipRgn, inBounds);    /* avoid wide-open clipRgn, be safe  */          RectRgn(newPort->visRgn, inBounds);    /* in case newBounds is screen bounds */          /* rowBytes is size of row, it must be rounded up to an even number of bytes */          newPort->portBits.rowBytes = ((inBounds->right - inBounds->left +                                  15) >> 4) << 1;          /* number of bytes in BitMap is rowBytes * number of rows */          /* see notes at end of Technote about using _NewHandle rather than _NewPtr*/          newPort->portBits.baseAddr =                  NewPtrClear(newPort->portBits.rowBytes * (long) (inBounds->bottom                                      - inBounds->top));          if (newPort->portBits.baseAddr == nil) { /* check to see if we had                              enough room for the bits */              SetPort(savePort);              ClosePort(newPort);      /* dump the visRgn and clipRgn */              DisposePtr((Ptr)newPort); /* dump the GrafPort */              return FALSE;            /* tell caller we failed */              }          *newOffscreen = newPort;          SetPort(savePort);                    return TRUE;               /* tell caller we succeeded! */      }void DestroyOffscreenGrafPort(GrafPtr oldOffscreen)      {          if(oldOffscreen != NULL && oldOffscreen->portBits.baseAddr != NULL)            {          ClosePort(oldOffscreen);            /* dump the visRgn and clipRgn */          DisposePtr(oldOffscreen->portBits.baseAddr);          DisposePtr((Ptr)oldOffscreen);            /* dump the port */            }      }