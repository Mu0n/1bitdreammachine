#include "Misc.c"      //InitMacStuff#include "MusicTime.c" //Time Manager related to music stuff#include "Sound.h"     //4tone stuff#define TEMPO 120   // default tempo - used in notes.h to calculate every timing - a better method that allows tempi changes should be devised#include "notes.h"     //note frequencies info, Make4#define kMAXWAVES  20#define kStringSpace 2000static long eta1,eta2,eta3,eta4,elapsedTime;WavePtr gInst[4];Wave    gBank[kMAXWAVES];short   gTempo; // to put in tune structure eventuallyshort   gWaveInstrCount = 0;#include "ChipTune2.c"Boolean   g4TUNReady = false;   //Ready to play the converted tuneTune tune;short gSignature; // to put in tune structure eventuallyFTSynthRec myRec;  // to put in tune structure eventuallyFTSoundRec mySnd;   // to put in tune structure eventually/*menus and their items */#define mApple   kBaseResID#define iAbout   1#define mFile    kBaseResID+1#define iOpen4TUN    1#define iConvert     2#define iQuit        4#define mPlay    kBaseResID+2#define iPlay       1#define iStop       2#define mHelp    kBaseResID+3#define iInstructions  1#define kAREYOUSURE 300  // are you sure dialogBoolean gDone = false;   //global flag that says quit appEventRecord wutup;      WindowPtr gWin; Fixed *cvtTable;         //Conversion table between SS codes and 4-tone freqsStringHandle ssNames;    //Keeps Studio Session instrument file namesStringHandle ftNames;    //Keeps the substitute waveform file namesint curSSIndex = 0,    curFTIndex = 0;    void SetUpWindow(void);void SetUpSpace(void);void SetUpMenu(void);void TouchPlayStop(void);void RefreshGraphics(void);void HandleMouseDown(void);void HandleMenuChoice(long menuChoice);void HandleAppleChoice(short theItem);void HandleFileChoice(short theItem);void HandleHelpChoice(short theItem);void HandlePlayChoice(short theItem);void ConvertSSFile(void);void MapInstrument(Str255 ssName);void AskInstrument(void);void AssignChipArrays(short fRefNum);void DestroyTune();void FillTuneCode(short endOfTracks,unsigned char cmdDetect,Tune *theTune);void CleanBeforeReuse();Boolean AreYouSure();void MyDisposPtr(Ptr p);void main(void)  {  char theChar;    InitMacStuff();  CreateConvertTable(cvtTable); /* SS note code -> something usable by the 4-tone synth. Used during playback*/  SetUpWindow();  SetUpSpace();  SetUpMenu();    while(gDone == false)    {    SystemTask();    TouchPlayStop();    GetNextEvent(everyEvent,&wutup);        switch(wutup.what)      {      case mouseDown:        HandleMouseDown();        break;      case keyDown:      case autoKey:        theChar= wutup.message & charCodeMask;		if((wutup.modifiers & cmdKey) !=0)			HandleMenuChoice(MenuKey(theChar));        break;        }    }  }  void HandleMouseDown(void)  {  WindowPtr window;  short thePart;  long menuChoice;    thePart = FindWindow(wutup.where, &window);  switch(thePart)    {    case inMenuBar:      menuChoice = MenuSelect(wutup.where);      HandleMenuChoice(menuChoice);      break;    case inSysWindow:      SystemClick(&wutup,window);      break;    case inContent:     if(window != FrontWindow()) SelectWindow(window);      break;    }  }  void HandleMenuChoice(long menuChoice)  {  int theMenu;  int theItem;    if(menuChoice != 0)    {    theMenu = HiWord(menuChoice);    theItem = LoWord(menuChoice);        switch(theMenu)      {      case mApple:        HandleAppleChoice(theItem);        break;      case mFile:        HandleFileChoice(theItem);        break;      case mPlay:        HandlePlayChoice(theItem);        break;      case mHelp:        HandleHelpChoice(theItem);        break;         }    HiliteMenu(0);    }  }void HandleHelpChoice(short theItem)  {  DialogPtr myDlg;  short itemHit = 0;    switch(theItem)    {    default:      break;    case iInstructions:      myDlg = GetNewDialog(kBaseResID+1,0,(WindowPtr)-1L);            do{ ModalDialog(nil,&itemHit);        } while(itemHit != ok);      DisposDialog(myDlg);      RefreshGraphics();      break;    }  }    void HandleAppleChoice(short theItem)  {  Str255 accName;  int accNumber;  DialogPtr myDlg;  short itemHit;  MenuHandle mHandle;  mHandle = GetMHandle(mApple);    switch(theItem)    {    case iAbout:      myDlg = GetNewDialog(kBaseResID+2,0,(WindowPtr)-1L);      ShowWindow(myDlg);      SetPort(myDlg);            do{ ModalDialog(nil,&itemHit);        } while(itemHit != ok);      DisposDialog(myDlg);      RefreshGraphics();      break;    default:      GetItem(mHandle,theItem,accName);      accNumber = OpenDeskAcc(accName);      break;    }  }  void HandleFileChoice(short theItem)  {  Boolean test;    switch(theItem)    {    case iOpen4TUN:      RefreshGraphics();      break;    case iConvert:      if(g4TUNReady == true)         {        test = AreYouSure();        if(test) CleanBeforeReuse();        else           {          RefreshGraphics();          break;          }        }      ConvertSSFile();      g4TUNReady = true;      RefreshGraphics();      break;    case iQuit:      gDone = true;      break;    }  }void HandlePlayChoice(short theItem)  {  MenuHandle mHandle;  int cmdDetect;    mHandle = GetMHandle(mPlay);  DisableItem(mHandle,iPlay);      EnableItem(mHandle,iPlay);  }  void TouchPlayStop(void)  {  MenuHandle mHandle;  mHandle = GetMHandle(mPlay);    if(g4TUNReady == true)     {    EnableItem(mHandle,iPlay);    EnableItem(mHandle,iStop);      }  else {    DisableItem(mHandle,iPlay);    DisableItem(mHandle,iStop);    }  }    void SetUpMenu(void)  {  MenuHandle mHandle;  Handle menuBar;  menuBar = GetNewMBar(kBaseResID);    if(menuBar == nil)    {    SysBeep(20);    ExitToShell();    }  SetMenuBar(menuBar);    mHandle = GetMHandle(mApple);  AddResMenu(mHandle,'DRVR');    TouchPlayStop();    DrawMenuBar();  ShowCursor();  }void SetUpWindow(void)  {  gWin = GetNewWindow(kBaseResID,nil,kMoveToFront);    SetPort(gWin);  ShowWindow(gWin);  }  void SetUpSpace(void)  {     ssNames = (StringHandle) NewHandle(kStringSpace*sizeof(unsigned char));    HLock((Handle)ssNames);  (*ssNames)[0] = 0;  HUnlock((Handle)ssNames);    ftNames = (StringHandle) NewHandle(kStringSpace*sizeof(unsigned char));    HLock((Handle)ftNames);  (*ftNames)[0] = 0;  HUnlock((Handle)ftNames);    RefreshGraphics();  }  void RefreshGraphics(void)  {  Str255 str;  int size = 0,offset = 0,i,amount=0;    Point leftC = {30,20},        rightC = {30,250};          SetPort(gWin);  FillRect(&(gWin->portRect),white);  MoveTo(leftC.h,leftC.v);  GetIndString(str,kBaseResID,1);  DrawString(str);  HLock((Handle)ssNames);if(ssNames != NULL)  {  while(1)    {    size = (*ssNames)[offset];    if(offset == curSSIndex) break; // needs a 0 terminated length character to finish    for(i=0;i<=(size);i++)      {      str[i] = (*ssNames)[i+offset];      }    for(i=offset+size+1;i<=255;i++) str[i] = 0; // Make sure the rest of the string is empty; may be useless.    offset += size+1;    amount++;    MoveTo(leftC.h,leftC.v + 20*amount);    DrawString(str);    }  }   HUnlock((Handle)ssNames);    offset=0;  amount = 0;  MoveTo(rightC.h,rightC.v);  GetIndString(str,kBaseResID,2);  DrawString(str);  HLock((Handle)ftNames);  if(ftNames != NULL)  {  while(1)    {    size = (*ftNames)[offset];    if(offset == curFTIndex) break;    for(i=0;i<=(size);i++)      {      str[i] = (*ftNames)[i+offset];      }    for(i=offset+size+1;i<=255;i++) str[i] = 0;    offset += size+1;    amount++;    MoveTo(rightC.h,rightC.v + 20*amount);    DrawString(str);    }  }   HUnlock((Handle)ftNames);  }    void ConvertSSFile(void)  {  SFReply reply; /* used in file operations */  SFTypeList myTypes; /* used in file operations */  OSErr err; /* error codes during file operations */  Point where = {50,50}; /* top left corner of Std file window */  long count,  /* number of bytes to be read by FSRead */       offsetCounter = 0,  /* file offset that marks beginning of note codes (past the SS song file header) */       eofTest = 0;  /* used to test if we're done after 6 tracks */  short fRefNum;    /* used in file operations */  Str255 str;        /* used in file operations */  short i,    /* loop variable */        endOfTracks=0;   /* counts the 0xB0 codes seen up to now */  unsigned char stringLeng,    /* recuperate the first pascal byte of an instrument character string, then use that length + 4 bytes to skip over it. */                cmdDetect=0;   /* used to scan the SS song file codes */  myTypes[0]='XSNG';   /* Those are the possible file type codes */  myTypes[1]='DSNG';  myTypes[2]='JSNG';        SFGetFile(where,"\pSelect a Studio Session song file",0L,1,myTypes,0L,&reply);  if(reply.good)    {    err = FSOpen(reply.fName,reply.vRefNum,&fRefNum);    if(err != noErr) ExitToShell();/* Tempo - 2 bytes */        count = 2;        err = FSRead(fRefNum,&count,&gTempo);    offsetCounter+=count;    /* Unused - 2 bytes */    count = 2;    err = SetFPos(fRefNum,fsFromMark,count);    offsetCounter+=count;    /* Signature (ie 4:4, 3:8, etc) - 2 bytes */        count = 2;    err = FSRead(fRefNum,&count,&gSignature);    offsetCounter+=count;    /* Check for instrument names - pascal strings (length byte + string (of length found previously) + 0000 0000), and/or 64 nul bytes buffer *//* First, assume presence of an instrument */        while(1)      {      count = 1;      err = FSRead(fRefNum,&count,&stringLeng);      offsetCounter+=count;            if(stringLeng==0) /*no instrument found */        {        count = 64; /*go forward through the buffer before exiting loop */        err = SetFPos(fRefNum,fsFromMark,count);        offsetCounter+=count;        break;        }      /* Instrument found. Ask for a waveform map */      count = stringLeng;      str[0]= (unsigned char) count;       err = FSRead(fRefNum,&count,&str[1]);      offsetCounter+=count;            MapInstrument(str);            count = 4;    /* skip over the 4 null bytes found after each strings */      err = SetFPos(fRefNum,fsFromMark,count);      offsetCounter+=count;       /* end of loop, ready to detect another instrument if there is one */       }        /* SafeKeep offsetCounter for the location of the beginning of note information. Use     AssignChipArrays to count the number of codes each track, in order to assign     the appropriate space to the Tune structure's arrays. */        AssignChipArrays(fRefNum); /* make a 1st pass at the note to count them up; assign space for arrays based on that */   SetFPos(fRefNum,fsFromStart,offsetCounter); /* restart where we left */     /* Command detection loop - ends when we accumulate 8 $B0 commands, each signaling the end of a track */      while(endOfTracks!=8)      {      count = 1;      err = FSRead(fRefNum,&count,&cmdDetect);            if(cmdDetect == 0xB0)         {         endOfTracks++; /*end of track detected */  /* we might be in a regular studio session song file, so at 6 ended tracks, check if         the file marker is at the EOF. If so, break from the while loop */        if(endOfTracks >= 6)          {          err = GetEOF(fRefNum,&eofTest);          err = GetFPos(fRefNum,&offsetCounter); /* since offsetCounter isn't used anymore, we use it now to check the current file mark position */          if(eofTest == offsetCounter) break;          }        }      else if(cmdDetect >= 0x00 && cmdDetect <= 0x2B ||               cmdDetect >= 0x41 && cmdDetect <= 0x6B ||              cmdDetect >= 0x81 && cmdDetect <= 0xAB)        { /* Note detected! */                FillTuneCode(endOfTracks,cmdDetect,&tune);                      count = 1;  /* note length */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);                  count = 1;   /* slur status */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);                  }      else if(cmdDetect == 0xBA || cmdDetect == 0xB5 || cmdDetect == 0xB2)        { /* bars (regular, dashed or repeat end) detected. */        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xBD)        { /* time signature changed.*/        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;   /* time sig top */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;   /*time sig bottom */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xB3)        { /* tempo change detected. */        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xC0)        { /* Ending number detected.*/                FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;    /* ending number */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xB4)        { /* Key signature change detected.*/        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xB9)        { /* Instrument change detected.*/        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1; /* next 2 bytes denote instrument number. These are according to the loading order that took place in the header */        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }      else if(cmdDetect == 0xB1)        { /* Repeat start detected */        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        count = 1;        err = FSRead(fRefNum,&count,&cmdDetect);        FillTuneCode(endOfTracks,cmdDetect,&tune);        }       else if(cmdDetect == 0xBF)         { /* Volume change for a Super Studio Session song file */         FillTuneCode(endOfTracks,cmdDetect,&tune);         count = 1;         err = FSRead(fRefNum,&count,&cmdDetect);         FillTuneCode(endOfTracks,cmdDetect,&tune);         count = 1;         err = FSRead(fRefNum,&count,&cmdDetect);         FillTuneCode(endOfTracks,cmdDetect,&tune);         count = 1;         err = FSRead(fRefNum,&count,&cmdDetect);         FillTuneCode(endOfTracks,cmdDetect,&tune);         count = 1;         err = FSRead(fRefNum,&count,&cmdDetect);         FillTuneCode(endOfTracks,cmdDetect,&tune);         count = 1;         err = FSRead(fRefNum,&count,&cmdDetect);         FillTuneCode(endOfTracks,cmdDetect,&tune);         }      }        err = FSClose(fRefNum);    AskInstrument();    }  else return;  /* Couldn't open the file */  }  void MapInstrument(Str255 ssName)  {  int i,      tempSize;  if(gWaveInstrCount < kMAXWAVES)    {      tempSize = ssName[0];        HLock((Handle)ssNames);    for(i=0;i<=tempSize;i++)      {      (*ssNames)[i+curSSIndex] = ssName[i];      }    HUnlock((Handle)ssNames);    curSSIndex += tempSize+1;    gWaveInstrCount++;     }  }  void AskInstrument(void){int i,j,k,    tempSize;DialogPtr myDlg;SFReply reply;Str255 ssName;curSSIndex = 0;for(k=0;k<gWaveInstrCount;k++)  {  tempSize = (*ssNames)[curSSIndex];  ssName[0]=tempSize;  for(j=0;j<tempSize;j++)  {  ssName[j+1]=(*ssNames)[j+curSSIndex+1];  }  curSSIndex+=tempSize+1;    myDlg = GetNewDialog(kBaseResID,0,(WindowPtr)-1L);    ParamText(ssName,nil,nil,nil);    DrawDialog(myDlg);    if(SFLoadWave(&((gBank)[k]),&reply)==true)      {      tempSize = reply.fName[0];      HLock((Handle)ftNames);      for(i=0;i<=tempSize;i++)        {        (*ftNames)[i+curFTIndex] = (reply.fName)[i];        }      HUnlock((Handle)ftNames);      curFTIndex += tempSize+1;      }    DisposDialog(myDlg);  }}void AssignChipArrays(short fRefNum)  {  long count;  short endOfTracks = 0;  unsigned char cmdDetect;  short bytesCounter[4]; /* accumulates notes for first 4 tracks */  OSErr err;    bytesCounter[0] = 0;  bytesCounter[1] = 0;  bytesCounter[2] = 0;  bytesCounter[3] = 0;    while(endOfTracks<4)      {      count = 1;      err = FSRead(fRefNum,&count,&cmdDetect);            if(cmdDetect == 0xB0) endOfTracks++; /*end of track detected */      else if(cmdDetect >= 0x00 && cmdDetect <= 0x2B ||               cmdDetect >= 0x41 && cmdDetect <= 0x6B ||              cmdDetect >= 0x81 && cmdDetect <= 0xAB)        { /* Note detected! */        bytesCounter[endOfTracks]+=3;        count = 2;        err = SetFPos(fRefNum,fsFromMark,count);        }      else if(cmdDetect == 0xBA || cmdDetect == 0xB5 || cmdDetect == 0xB2)         { /* bars detected. */        bytesCounter[endOfTracks]++;        }      else if(cmdDetect == 0xBD || cmdDetect == 0xB3 || cmdDetect == 0xB9 || cmdDetect == 0xB1)        { /* Time sig, tempo, instrument change, repeat start */        bytesCounter[endOfTracks]+=3;        count = 2;        err = SetFPos(fRefNum,fsFromMark,count);        }      else if(cmdDetect == 0xC0 || cmdDetect == 0xB4)        { /* Ending or signature */                bytesCounter[endOfTracks]+=2;        count = 1;        err = SetFPos(fRefNum,fsFromMark,count);        }       else if(cmdDetect == 0xBF)         { /* Volume change */         count = 5;         bytesCounter[endOfTracks]+=6;         err = SetFPos(fRefNum,fsFromMark,count);         }      } /* end of while */            if(bytesCounter[0] > 0)      tune.code[0] = (unsigned char *)NewPtr(bytesCounter[0]);    if(bytesCounter[1] > 0)      tune.code[1] = (unsigned char *)NewPtr(bytesCounter[1]);    if(bytesCounter[2] > 0)      tune.code[2] = (unsigned char *)NewPtr(bytesCounter[2]);    if(bytesCounter[3] > 0)      tune.code[3] = (unsigned char *)NewPtr(bytesCounter[3]);  }    void DestroyTune()  {  MyDisposPtr((Ptr)(tune.code[0]));  MyDisposPtr((Ptr)(tune.code[1]));  MyDisposPtr((Ptr)(tune.code[2]));  MyDisposPtr((Ptr)(tune.code[3]));  } void MyDisposPtr(Ptr p){   if(NULL != p){      DisposePtr(p);   }}void FillTuneCode(short endOfTracks,unsigned char cmdDetect,Tune *theTune)  {  if(endOfTracks==0) theTune->code[0][theTune->i++] = cmdDetect;  if(endOfTracks==1) theTune->code[1][theTune->j++] = cmdDetect;  if(endOfTracks==2) theTune->code[2][theTune->k++] = cmdDetect;  if(endOfTracks==3) theTune->code[3][theTune->l++] = cmdDetect;  }  Boolean AreYouSure(void){DialogPtr myDlg;short itemHit;itemHit = CautionAlert(kAREYOUSURE,nil);if(itemHit == ok) return true;return false;}void CleanBeforeReuse(void){DestroyTune();if(ssNames!=NULL) DisposHandle((Handle)ssNames);if(ftNames!=NULL) DisposHandle((Handle)ftNames);gWaveInstrCount = 0;curSSIndex = 0;curFTIndex = 0;g4TUNReady = false;tune.i=0;tune.j=0;tune.k=0;tune.l=0;SetUpSpace();}