#include "Misc.c"      	//InitMacStuff#include "MusicTime.c" 	//Time Manager tasks to launch music stuff#include <StandardFile.h>#include <Sound.h>#include "string.h"#include "pascal.h"#include "Types.h"#include "LoadSong.c"#define TEMPO 150 /* MUST be declared before including notes.h. This is bpm for quarter notes*/#include "notes.h"//Global variablesBoolean gDone = false; 	//flag that lets you quit the programEventRecord wutup; 		//Event record to deal with the main loopBoolean gIsFileRead = false; //attempt to load a file only if one hasn't been loaded yetshort fRefNum;   //is used to close the file eventually and access parts of itWindowRecord myWin;WindowPtr myWinPtr;Rect r;Boolean runWithSound = true; //if set to false, won't hang up in System 7//Global Song variablesshort gTempo; //song tempo, 2 bytes, goes from 10 to 450short gSignature; //song signature code. 2 bytes: top and bottom respectively. Goes from 1-32 each//Methodsvoid HandleMouseDown(void);SFReply SelectSSFile(void);void DisplaySSFileName(SFReply);void DisplaySSFileInfo(SFReply);void CloseDownThisWholeThing(void);void PlayNote(short,short,short);	int getDuration(short);int getNote(char*, short);void pauseBetweenEntries(void);void main(void){		InitMacStuff();		//Sets the window area	SetRect(&r,10,40,500,300);	myWinPtr=NewWindow(&myWin,&r,"\pStudio Session Analyzer",true,4,(WindowPtr)-1,true,0);	SetPort(myWinPtr);		//Main loop, will quit on clicking	while(gDone == false)	{		SystemTask();		GetNextEvent(everyEvent, &wutup);				switch(wutup.what) //event checking inner loop		{		case mouseDown:			HandleMouseDown();			break;		}				if(gIsFileRead == false)			{			SFReply fileReply; //These 2 variables are used to assess the user's file choice			OSErr err; 		//carries errors from attempting to open the file  						gIsFileRead = true;							fileReply = SelectSSFile(); 		//attempt to get a file to open from a dialog			if(!fileReply.good) {				ExitToShell(); 		//something wrong happened, quit				}			err = FSOpen(fileReply.fName, fileReply.vRefNum, &fRefNum);			if(err == noErr) {				DisplaySSFileName(fileReply); //file is open, give info on file name				DisplaySSFileInfo(fileReply); //file is open, give info in dialog			}			else ExitToShell();			err = FSClose(fRefNum);			} //end of dealing with reading a file	} //end of main loop} // end of main/* * Handle keyboard event to pause between stuff to read */ void pauseBetweenEntries(void)	{	Rect eraseRect;			while(true) //bad programming!		{		SystemTask();		GetNextEvent(everyEvent, &wutup);			switch(wutup.what) //event loop looking for mouse clicks and keyboard key presses			{			case mouseDown:				ExitToShell(); // quit the program with a mouse click				break;			case keyDown: //deal with the next note with any key stroke				SetRect(&eraseRect, 0, 56, 500, 342);				FillRect(&eraseRect, white);				return;			}		} 	} /* *	Method that reacts to various mouse clicks*/void HandleMouseDown(void)	{  		gDone = true;  	}	/*  * Give a bunch of info to the user */void DisplaySSFileName(SFReply reply)	{	MoveTo(10,10);	DrawString("\pSong file: ");	DrawString(reply.fName);	}	void DisplaySSFileInfo(SFReply reply)	{	OSErr err; //used to provide info for errors during reading	ConstStr255Param pascalstring; //String objects in order to give feedback	char tempstring[100];		//used to detect the structure of a SS song file  	short i,    /* loop variable */        endOfTracks=0;   /* counts the 0xB0 codes seen up to now */	unsigned char stringLeng,    /* recuperate the first pascal byte of an instrument character string, then use that length + 4 bytes to skip over it. */                cmdDetect=0,                cmdDetect2=0,                cmdDetect3=0;   /* used to scan the SS song file codes */    Str255 str;        // instrument name string    long count,  // number of bytes to be read by FSRead       offsetCounter = 0,  // file offset that marks beginning of note codes (past the SS song file header)       eofTest = 0,   // used to test if we're done after 6 tracks       nbCmdsInLine = 0;  //used to increment the y position    short trackStrY = 55; //used to locate the drawstring of the track data to be written    char noteName[100]; //used to describe the note in a more verbose way, from getNote        //Read the Tempo    count = 2;    err = FSRead(fRefNum, &count, &gTempo);    if(err != noErr) CloseDownThisWholeThing();    offsetCounter += count;        //Write Tempo    sprintf(tempstring,"Tempo: %d",gTempo);    pascalstring=CtoPstr(tempstring);    MoveTo(10,25);    DrawString(pascalstring);        //Read empty 2 bytes    count = 2;    err = SetFPos(fRefNum, fsFromMark, count);    if(err != noErr) CloseDownThisWholeThing();        //Read Signature    count = 2;    err = FSRead(fRefNum, &count, &gSignature);    if(err != noErr) CloseDownThisWholeThing();    offsetCounter += count;        //Write Signature    sprintf(tempstring,"Signature: %d",(gSignature >> 8) & 0x0F);    pascalstring=CtoPstr(tempstring);    MoveTo(10,40);    DrawString(pascalstring);    sprintf(tempstring,":%d",gSignature & 0x0F);    pascalstring=CtoPstr(tempstring);    DrawString(pascalstring);        // Check for instrument names -     // pascal strings (length byte + string (of length found previously)     //      + 0000 0000), and/or 64 nul bytes buffer	// First, assume presence of an instrument  	      while(1)      {      count = 1;      err = FSRead(fRefNum,&count,&stringLeng);      offsetCounter += count;            if(stringLeng==0) // no instrument found        {        count = 64; // go forward through the buffer before exiting loop         err = SetFPos(fRefNum,fsFromMark,count);        offsetCounter += count;        break;        }      // Instrument found.      count = stringLeng;      str[0]= (unsigned char) count;       err = FSRead(fRefNum,&count,&str[1]);      if(err != noErr) CloseDownThisWholeThing();      offsetCounter += count;                        count = 4;    // skip over the 4 null bytes found after each strings      err = SetFPos(fRefNum,fsFromMark,count);      offsetCounter+=count;            } // end of loop, ready to detect another instrument if there is one           //SetFPos(fRefNum,fsFromStart,offsetCounter); /* restart where we left */       	//Write Track info header:    	MoveTo(10,trackStrY);	    	sprintf(tempstring,"Track %d: ",(endOfTracks+1));    	pascalstring=CtoPstr(tempstring);    	DrawString(pascalstring);    	    //Read the first track only    while(endOfTracks < 1)    	{        	MoveTo(30,trackStrY+15);	    	count = 1;      	err = FSRead(fRefNum,&count,&cmdDetect);    	if(err != noErr) CloseDownThisWholeThing();            	switch(cmdDetect)       		{       		case 0xB0: //end of a Track, needs no more byte       			endOfTracks++;       			DrawString("\p End of Track");       			if(endOfTracks < 1)       				{       				//trackStrY += 15;    				//MoveTo(10,trackStrY);    				sprintf(tempstring,"Track %d: ",(endOfTracks+1));    				pascalstring=CtoPstr(tempstring);    				DrawString(pascalstring);    				}       			break;       		case 0xB9: //instrument change, needs 2 more bytes       			DrawString("\pInstrument Change: ");       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect2); //first byte of instrument #       			sprintf(tempstring, "%d", cmdDetect2);       			pascalstring = CtoPstr(tempstring);       			DrawString(pascalstring);       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect3); //second byte of instrument #       			sprintf(tempstring, "%d", cmdDetect3);       			pascalstring = CtoPstr(tempstring);       			DrawString(pascalstring);       			break;       		case 0xC0: //ending number, needs 1 more byte       			count = 1;       			err = FSRead(fRefNum, &count, &cmdDetect);       			DrawString("\pSection end");       			break;       		case 0xBD: //time signature, needs 2 more bytes       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect2);        			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect3);        			DrawString("\pTime Signature change");       			break;       		case 0xBA: //bar line, needs no more byte       			DrawString("\pBar line");       			break;       		case 0xB5: //dashed bar line, needs no more byte       			DrawString("\pDashed bar line");       			break;       		case 0xB2: //repeat bar end, needs no more byte       			DrawString("\pRepeat bar end");       			break;       		case 0xB4: //key signature change, needs 1 more byte:       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect2);        			DrawString("\pKey Signature change");       			break;       		case 0xB3: //tempo change, needs 2 more bytes       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect2);        			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect3);        			       			DrawString("\pTempo Change");       			break;       		case 0xB1: //repeat bar start, needs 2 more bytes:       			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect2);        			count = 1;       			err = FSRead(fRefNum, &count,&cmdDetect3);        			       			DrawString("\pRepeat Section Start");       			break;       		default: //note maybe detected 	      		if(cmdDetect >= 0x00 && cmdDetect <= 0x2B ||               	   cmdDetect >= 0x41 && cmdDetect <= 0x6B ||              	   cmdDetect >= 0x81 && cmdDetect <= 0xAB)              	   {              	   //decimal note number       			   sprintf(tempstring," Note:%d",cmdDetect);    			   pascalstring=CtoPstr(tempstring);    			   DrawString(pascalstring);    			   //hex note number    			   sprintf(tempstring, "(0x%02X)", cmdDetect);    			   pascalstring=CtoPstr(tempstring);    			   DrawString(pascalstring);    			                 	   count = 1;  // note length        		   err = FSRead(fRefNum,&count,&cmdDetect2);    			   if(err != noErr) CloseDownThisWholeThing();       			   sprintf(tempstring," Length:%d",cmdDetect2);    			   pascalstring=CtoPstr(tempstring);    			   DrawString(pascalstring);    			       			   //hex note number    			   sprintf(tempstring, "(0x%02X)", cmdDetect2);    			   pascalstring=CtoPstr(tempstring);    			   DrawString(pascalstring);       			          			   count = 1;   // slur status                   err = FSRead(fRefNum,&count,&cmdDetect3);    			   if(err != noErr) CloseDownThisWholeThing();       			   sprintf(tempstring," Slur:%d",cmdDetect3);    			   pascalstring=CtoPstr(tempstring);    			   DrawString(pascalstring);    			       			   //write a more verbose note label    			   noteName[0] = 0;    			   getNote(&noteName[0], cmdDetect);    			   MoveTo(30,trackStrY+29);    			   pascalstring = CtoPstr(noteName);    			   DrawString(pascalstring);    			       			   if(runWithSound) PlayNote(cmdDetect,cmdDetect2,cmdDetect3);    			                 	   nbCmdsInLine++;              	   if(nbCmdsInLine ==8)              	   	{              	   	//trackStrY+=15;              	   	//MoveTo(10,trackStrY);              	   	nbCmdsInLine=0;              	   	}       		       } //end really a note was detected       		              			else{       				DrawString("\pUnknown code:");       				sprintf(tempstring," %02X", cmdDetect);       				pascalstring = CtoPstr(tempstring);       				DrawString(pascalstring);       				}       		    break;       		} //end of the command switch                pauseBetweenEntries();            	} //end of the while in the command detection area until it finds x end of track command    	}//end of DisplaySSFileInfo	/* * plays a cheap square wave rendition of a note */ void PlayNote(short pitch,short length, short slur)	{	Ptr myPtr;	Handle myHandle;	SWSynthPtr mySWPtr;	int freq,i,timer;	int finalNoteLength;		myHandle = NewHandle(5+sizeof(short));	HLock(myHandle);	myPtr = *myHandle;	mySWPtr=(SWSynthPtr)myPtr;	mySWPtr->mode=swMode;		finalNoteLength = getDuration(length);		if(pitch==0x00)		{		ASSIGN(mySWPtr->triplets[0],getNote(nil, pitch),0,finalNoteLength);		}	else ASSIGN(mySWPtr->triplets[0],getNote(nil, pitch),200,finalNoteLength); //a note		if(pitch!=0x00) StartSound((Ptr)mySWPtr,(5+3*sizeof(short)),(SndCompletionProcPtr)nil);	timer=TickCount();	while(TickCount()-timer<finalNoteLength);	if(pitch!=0x00) StopSound();		HUnlock(myHandle);	}	/* * Maps the pitch read from the SS song to a freq done with MakeNote in notes.h */ int getNote(char *noteName, short pitchInput)	{	int octaveFromBottom; // 0 = lowest, ..., 6 = highest	int noteInOctave; // 1 = C, ... 7 = B;	int accidentalOffset = 0;	char tempstring[10];	int pitch = pitchInput; //make a local copy so we can edit out the accidentals		if(pitch > 0x80)		{		accidentalOffset = 1; //is a sharp note		pitch -= 0x80;		}	else if(pitch > 0x40) 		{		accidentalOffset = -1; //is a flat note		pitch -= 0x40;		}			octaveFromBottom = (pitch-1)/7;	noteInOctave = (pitch-1)%7;		switch(noteInOctave) //conversion from SS note value to chromatic value in notes.h		{		case 0:			noteInOctave = 0; //C			strcpy(noteName,"C");			break;		case 1:			noteInOctave = 2; //D			strcpy(noteName,"D");			break;		case 2:			noteInOctave = 4; //E			strcpy(noteName,"E");			break;		case 3:			noteInOctave = 5; //F			strcpy(noteName,"F");			break;		case 4:			noteInOctave = 7; //G			strcpy(noteName,"G");			break;		case 5:			noteInOctave = 9; //A			strcpy(noteName,"A");			break;		case 6:			noteInOctave = 11; //B			strcpy(noteName,"B");			break;		}			if(accidentalOffset != 0)		{		noteInOctave += accidentalOffset; // apply flat or sharp		if(accidentalOffset==1) strcat(noteName, "#");		else if(accidentalOffset==-1) strcat(noteName, "b");				if(noteInOctave == -1) //flat note that overflows			{			if(octaveFromBottom > 0) //go down an Octave unless at the bottom				{				noteInOctave = 11; //changes to what we'll hear but not what we'll read (ie Cb)				octaveFromBottom--;				}			}		else if(noteInOctave == 12) //sharp note that overflows			{			if(octaveFromBottom < 6) //go up an Octave unless at the top				{				noteInOctave = 0; //changes to what we'll hear but not what we'll read (ie B#)				octaveFromBottom++;				}			}		}	sprintf(tempstring," (%d)",octaveFromBottom);	strcat(noteName,tempstring);	return MakeNote(noteInOctave, octaveFromBottom-3);	}/* * maps the length read from the SS song file to a tick duration defined in notes.h */int getDuration(short length)	{	switch(length)		{		case 0x03:			return THIR; // 1/32		case 0x02:			return THIR/3; // 1/32 triplet		case 0x06:			return SIXT; // 1/16		case 0x04:			return SIXT/3; // 1/16 triplet		case 0x09:			return SIXT + SIXT/2; // 1/16 dotted		case 0x0C:			return EIGH; // 1/8		case 0x08:			return EIGH/3; // 1/8 triplet		case 0x15:			return EIGH + EIGH/2 + EIGH/4; // 1/8 double dotted		case 0x12:			return EIGH + EIGH/2; // 1/8 dotted		case 0x18:			return QUAR; // 1/4		case 0x10:			return QUAR/3; // 1/4 triplet		case 0x2A:			return QUAR + QUAR/2 + QUAR/4; // 1/4 double dotted		case 0x24:			return QUAR + QUAR/2; // 1/4 dotted		case 0x30:			return HALF; // 1/2		case 0x20:			return HALF/3; // 1/2 triplet		case 0x54:			return HALF + HALF/2 + HALF/4; // 1/2 double dotted		case 0x48:			return HALF + HALF/2; // 1/2 dotted		case 0x60:			return WHOL; // 1		case 0x40:			return WHOL/3; // 1 triplet		case 0xA8:			return WHOL + WHOL/2 + WHOL/4; // 1 double dotted		case 0x90:			return WHOL + WHOL/2; // 1 dotted		default:			return THIR; //something going wrong		}	}	/* * This method is called to close everything, assuming the file is opened (we close it first) */ void CloseDownThisWholeThing(void)	{	FSClose(fRefNum);	MoveTo(200,200);	DrawString("\pCRASH");	ExitToShell();	}