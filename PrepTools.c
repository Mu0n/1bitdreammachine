/* PrepTools.c */#include "PrepTools.h"/*------ InitMacStuff   Inits all the Toolbox managers   This sequence is almost always used as is                      ---------*/void InitMacStuff(void)	{	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	GetDateTime((unsigned long *)(&qd.randSeed));	FlushEvents(everyEvent,0);	}/*------ End of initMacStuff ------*//*------ Hide Menu bar ---------- This probably breaks with much newer macs */void HideMyMenuBar(void)	{	Rect rcMBar;	short *setMBarHeight;	 	setMBarHeight=(short *)0x0BAA;	 	if ( gs_hrgnMBar == 0L) 		{		gs_dyMBar  =  GetMBarHeight();				*setMBarHeight=0;				rcMBar = qd.screenBits.bounds;		rcMBar.bottom = rcMBar.top + gs_dyMBar;				gs_hrgnMBar = NewRgn();		RectRgn( gs_hrgnMBar, &rcMBar );		UnionRgn( GetGrayRgn(), gs_hrgnMBar, GetGrayRgn() );		PaintOne(nil,gs_hrgnMBar);		}	}/*------- End of HideMyMenuBar -------*/ /*--------- Show My Menu Bar -----------*/void ShowMyMenuBar(void)	{	short *setMBarHeight;	setMBarHeight=(short *)0x0BAA;	 	if( gs_hrgnMBar) 		{		*setMBarHeight=gs_dyMBar;		DiffRgn(GetGrayRgn(), gs_hrgnMBar, GetGrayRgn());		DisposeRgn(gs_hrgnMBar);		gs_hrgnMBar=0L;	    }	}/*------- End of Hide Menu Bar -------*/  /*--------- Ranged Random -----------*/unsigned short rangeRandom(unsigned short min, unsigned short max )/* the function will calculate the correct max and min values */	{	long range;	long randomNumber;	  	range = MAX(min,max) - MIN(min,max) + 1;	randomNumber=Random();	randomNumber=ABS(randomNumber);	  	return( (randomNumber * range)/kRandomUpperLimit+min);	}/*--------- End of Ranged Random -----------*//* WholeScreen - Will create and set the current port to a screen-sized featureless window filled with    the pattern of your choice. You are responsible to deal with any previous windows and ports    NOTE: use DisposeWindow to get rid of it when you're done    NOTE2: if your screen is larger than the Plus' 512x342, then that's what you'll get if you want to develop          for machines that are not compact macs with 9" b&w monitors.   */WindowPtr WholeScreen(Pattern thePat, Boolean wantMenus)	{	WindowPtr window;	Rect r;	r=qd.screenBits.bounds;	r.top=kMenuBarHeight;	if(wantMenus) window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);	else window=NewWindow(nil,&(qd.screenBits.bounds),nil,true,plainDBox,kMoveToFront,false,0);	SetPort(window);	FillRect(&(window->portRect), thePat);	return window;	}/*--------- End of WholeScreen --------*//* Mac Plus Area - creates a 512x342 screen centered in the middle, with correctClip region. If the screen is larger than that, makes a border with borderPat as itspattern. */WindowPtr MacPlusArea(Pattern borderPat, Pattern middlePat,Boolean wantMenus, WindowRecord *winrec)	{	WindowPtr window;	Rect r;	r=qd.screenBits.bounds;	r.top=kMenuBarHeight;	if(kScreenWidth <=512 && kScreenHeight <=342)		{		WholeScreen(middlePat,wantMenus);		}	else 		{		if(wantMenus) window=NewWindow(winrec,&r,nil,true,plainDBox,kMoveToFront,false,0);		else window=NewWindow(winrec,&(qd.screenBits.bounds),nil,true,plainDBox,kMoveToFront,false,0);	 		SetPort(window);		FillRect(&(window->portRect), borderPat);		//this part will center the window 512x342 port to the middle of the screen as best it can		if(wantMenus) 			{			PortSize(512,342);			MovePortTo((kScreenWidth-512)/2,(kScreenHeight-342-kMenuBarHeight)/2); 			}		else 			{			MovePortTo((kScreenWidth-512)/2,(kScreenHeight-342)/2);			PortSize(512,342);			}		ClipRect(&(window->portRect));		CLS(middlePat,wantMenus);		}	return window;	}/*--------- End of MacPlusArea -----------*//*--------- Forces a Mac Plus Area - creates a 512x342 screen centered in the middle, with correct Clip region. Doesn't care about the real size of the screen, so this is a more restricted version of MacPlusArea seen above -----------*/WindowPtr ForceMacPlusScreen(Pattern thePat, Boolean wantMenus)	{	WindowPtr window;	Rect r;	SetRect(&r,0,0,512,342);	if(wantMenus) window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);	else window=NewWindow(nil,&r,nil,true,plainDBox,kMoveToFront,false,0);	SetPort(window);	FillRect(&(window->portRect), thePat);	return window;	}/*--------- End of MacPlusArea -----------*//*--------- CLS ("CLear Screen")---------------     will wipe the current activated port with a Pattern of your choice **/void CLS(Pattern thePat, Boolean wantMenus)	{	Rect r;	WindowPtr window;	GetPort(&window);	r=window->portRect;	r.top=kMenuBarHeight;	if(wantMenus) FillRect(&r,thePat);	else FillRect(&(window->portRect),thePat);	}/*--------- End of CLS --------*//* Old Load File will summon one of the earliest file open dialogs around which allows you to filter to up to 4 file types that will show up in the selection. returns a short with the file number if successful. returns 0 if it fails */short OldLoadFile(SFTypeList myTypes)	{	SFReply reply;      //GetFile reply	short openResult=0; //trails file number	long count;         //used to read the data	Point where={50,50};//SFGetFile dialog location		  	SFGetFile(where,"\pSelect a file",0L,1,myTypes,0L,&reply);		  	if(reply.good) FSOpen(reply.fName,reply.vRefNum,&openResult);	return openResult;	}/*--------- End of OldLoadFile --------*//* GetScreenWidth - without much surprise, gets you the width of the physical screen from the mac global qd*/int GetScreenWidth(void)	{	return qd.screenBits.bounds.right-qd.screenBits.bounds.left;	}/*--------- End of GetScreenWidth --------*//* GetScreenHeight - without much surprise, gets you the height of the physical screen from the mac global qd*/ int GetScreenHeight(void)	{	return qd.screenBits.bounds.bottom-qd.screenBits.bounds.top;	}/*--------- End of GetScreenHeight --------*//* PStringCat - puts b at the end of a and forms a new Str255 string.*/ void PStringCat(Str255 a, Str255 b)	{	short len;	  	if((a[0]+b[0]) > 255) len = 255-a[0];	else len = b[0];	  	BlockMove(&(b[1]),&(a[a[0]+1]),len);	a[0] += len;	}/*--------- End of PStringCat --------*//* PStringCopy - copies the string a into b*/void PStringCopy(Str255 a, Str255 b)	{	BlockMove(a,b,a[0]+1);	}/*--------- End of PStringCopy --------*/